/*
Usage: 
  Add this script to a document (doesn't need to be the one you wish to export): 
    - Tools > Script Manager > New
    - Select "Blank Project", then paste this code in and save.
    
  Preparing files:
    - Put all documents you wish to convert into a folder in your docs list,
      called "DocsToConvertToMarkdown"
  
  Running the script:
    - Tools > Script Manager
    - Select "convertDefaultFolder" function.
    - Click Run button.
    - All documents in the folder will be converted to markdown,
      and resulting files put in a new subfolder called "ExportedMarkdown-TIMESTAMP"
      where TIMESTAMP is the current ISO GMT timestamp.
      
  Using different folders:
    - You can call convertFolder(folderName) with a different folder name as required.
    
*/

function convertDefaultFolder() {
  convertFolder('DocsToConvertToMarkdown');
}

function convertFolder(folderName) {
  var folder = DocsList.getFolder(folderName);
  var files = folder.getFilesByType(DocsList.FileType.DOCUMENT);
  var timeStamp = Utilities.formatDate(new Date(), "GMT", "yyyy-MM-dd'T'HH:mm:ss'Z'")
  var exportFolder = folder.createFolder("ExportedMarkdown-" + timeStamp)

  var convertedDocNames = "";
  
  for (var i in files) {
    var doc = DocumentApp.openById(files[i].getId());
    var attachments = convertToMarkdownAttachments(doc);
    var docFolder = exportFolder.createFolder(doc.getName());
    convertedDocNames += doc.getName() + "\n";
    for (var j in attachments) {
      var attachment = attachments[j];
      docFolder.createFile(attachment.fileName, attachment.content, attachment.mimeType);
    }
  }

  //FIXME display some other way? Browser only works from a spreadsheet!
  //Browser.msgBox("Export complete", "Converted documents:\n" + convertedDocNames, Browser.Buttons.OK)
}

function mailActiveDocumentAsMarkdown() {
  var doc = DocumentApp.getActiveDocument();
  var attachments = convertToMarkdownAttachments(doc);
  mailWithAttachments(doc, attachments);
}

function mailWithAttachments(document, attachments) {
  MailApp.sendEmail(
    Session.getActiveUser().getEmail(), 
    "[MARKDOWN_MAKER] "+document.getName(), 
    "Your converted markdown document is attached (converted from " + document.getUrl() + ")" +
    "\n\nDon't know how to use the format options? See http://github.com/mangini/gdocs2md\n",
    { "attachments": attachments });
}

function convertToMarkdownAttachments(document) {
  var numChildren = document.getActiveSection().getNumChildren();
  var text = "";
  var inSrc = false;
  var inClass = false;
  var globalImageCounter = 0;
  var globalListCounters = {};
  // edbacher: added a variable for indent in src <pre> block. Let style sheet do margin.
  var srcIndent = "";
  
  var attachments = [];
  
  // Walk through all the child elements of the doc.
  for (var i = 0; i < numChildren; i++) {
    var child = document.getActiveSection().getChild(i);
    var result = processParagraph(i, child, inSrc, globalImageCounter, globalListCounters);
    globalImageCounter += (result && result.images) ? result.images.length : 0;
    if (result!==null) {
      if (result.sourcePretty==="start" && !inSrc) {
        inSrc=true;
        text+="<pre class=\"prettyprint\">\n";
      } else if (result.sourcePretty==="end" && inSrc) {
        inSrc=false;
        text+="</pre>\n\n";
      } else if (result.source==="start" && !inSrc) {
        inSrc=true;
        text+="<pre>\n";
      } else if (result.source==="end" && inSrc) {
        inSrc=false;
        text+="</pre>\n\n";
      } else if (result.inClass==="start" && !inClass) {
        inClass=true;
        text+="<div class=\""+result.className+"\">\n";
      } else if (result.inClass==="end" && inClass) {
        inClass=false;
        text+="</div>\n\n";
      } else if (inClass) {
        text+=result.text+"\n\n";
      } else if (inSrc) {
        text+=(srcIndent+escapeHTML(result.text)+"\n");
      } else if (result.text && result.text.length>0) {
        text+=result.text+"\n\n";
      }
      
      if (result.images && result.images.length>0) {
        for (var j=0; j<result.images.length; j++) {
          attachments.push( {
            "fileName": result.images[j].name,
            "mimeType": result.images[j].type,
            "content": result.images[j].bytes } );
        }
      }
    } else if (inSrc) { // support empty lines inside source code
      text+='\n';
    }
      
  }
  
  attachments.push({"fileName":document.getName()+".md", "mimeType": "text/x-markdown", "content": text});

  return attachments;
}

function escapeHTML(text) {
  return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// Process each child element (not just paragraphs).
function processParagraph(index, element, inSrc, imageCounter, listCounters) {
  // First, check for things that require no processing.
  if (element.getNumChildren()==0) {
    return null;
  }  
  // Punt on TOC.
  if (element.getType() === DocumentApp.ElementType.TABLE_OF_CONTENTS) {
    return {"text": "[[TOC]]"};
  }
  
  // Set up for real results.
  var result = {};
  var pOut = "";
  var textElements = [];
  var imagePrefix = "image_";
  
  // Handle Table elements. Pretty simple-minded now, but works for simple tables.
  // Note that Markdown does not process within block-level HTML, so it probably 
  // doesn't make sense to add markup within tables.
  if (element.getType() === DocumentApp.ElementType.TABLE) {
    textElements.push("<table>\n");
    var nCols = element.getChild(0).getNumCells();
    for (var i = 0; i < element.getNumChildren(); i++) {
      textElements.push("  <tr>\n");
      // process this row
      for (var j = 0; j < nCols; j++) {
        textElements.push("    <td>" + element.getChild(i).getChild(j).getText() + "</td>\n");
      }
      textElements.push("  </tr>\n");
    }
    textElements.push("</table>\n");
  }
  
  // Process various types (ElementType).
  for (var i = 0; i < element.getNumChildren(); i++) {
    var t=element.getChild(i).getType();
    
    if (t === DocumentApp.ElementType.TABLE_ROW) {
      // do nothing: already handled TABLE_ROW
    } else if (t === DocumentApp.ElementType.TEXT) {
      var txt=element.getChild(i);
      pOut += txt.getText();
      textElements.push(txt);
    } else if (t === DocumentApp.ElementType.INLINE_IMAGE) {
      result.images = result.images || [];
      var contentType = element.getChild(i).getBlob().getContentType();
      var extension = "";
      if (/\/png$/.test(contentType)) {
        extension = ".png";
      } else if (/\/gif$/.test(contentType)) {
        extension = ".gif";
      } else if (/\/jpe?g$/.test(contentType)) {
        extension = ".jpg";
      } else {
        throw "Unsupported image type: "+contentType;
      }
      var name = imagePrefix + imageCounter + extension;
      imageCounter++;
      textElements.push('![image alt text]('+name+')');
      result.images.push( {
        "bytes": element.getChild(i).getBlob().getBytes(), 
        "type": contentType, 
        "name": name});
    } else if (t === DocumentApp.ElementType.PAGE_BREAK) {
      // ignore
    } else if (t === DocumentApp.ElementType.HORIZONTAL_RULE) {
      textElements.push('* * *\n');
    } else if (t === DocumentApp.ElementType.FOOTNOTE) {
      textElements.push(' (NOTE: '+element.getChild(i).getFootnoteContents().getText()+')');
    } else {
      throw "Paragraph "+index+" of type "+element.getType()+" has an unsupported child: "
      +t+" "+(element.getChild(i)["getText"] ? element.getChild(i).getText():'')+" index="+index;
    }
  }

  if (textElements.length==0) {
    // Isn't result empty now?
    return result;
  }
  
  // evb: Add source pretty too. (And abbreviations: src and srcp.)
  // process source code block:
  if (/^\s*---\s+srcp\s*$/.test(pOut) || /^\s*---\s+source pretty\s*$/.test(pOut)) {
    result.sourcePretty = "start";
  } else if (/^\s*---\s+src\s*$/.test(pOut) || /^\s*---\s+source code\s*$/.test(pOut)) {
    result.source = "start";
  } else if (/^\s*---\s+class\s+([^ ]+)\s*$/.test(pOut)) {
    result.inClass = "start";
    result.className = RegExp.$1;
  } else if (/^\s*---\s*$/.test(pOut)) {
    result.source = "end";
    result.sourcePretty = "end";
    result.inClass = "end";
  } else if (/^\s*---\s+jsperf\s*([^ ]+)\s*$/.test(pOut)) {
    result.text = '<iframe style="width: 100%; height: 340px; overflow: hidden; border: 0;" '+
                  'src="http://www.html5rocks.com/static/jsperfview/embed.html?id='+RegExp.$1+
                  '"></iframe>';
  } else {

    prefix = findPrefix(inSrc, element, listCounters);
  
    var pOut = "";
    for (var i=0; i<textElements.length; i++) {
      pOut += processTextElement2(inSrc, textElements[i]);
    }

    // replace Unicode quotation marks
    pOut = pOut.replace('\u201d', '"').replace('\u201c', '"');
 
    result.text = prefix+pOut;
  }
  
  return result;
}

// Add correct prefix to list items.
function findPrefix(inSrc, element, listCounters) {
  var prefix="";
  if (!inSrc) {
    if (element.getType()===DocumentApp.ElementType.PARAGRAPH) {
      var paragraphObj = element;
      switch (paragraphObj.getHeading()) {
        // Add a # for each heading level. No break, so we accumulate the right number.
        case DocumentApp.ParagraphHeading.HEADING6: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING5: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING4: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING3: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING2: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING1: prefix+="# ";
        default:
      }
    } else if (element.getType()===DocumentApp.ElementType.LIST_ITEM) {
      var listItem = element;
      var nesting = listItem.getNestingLevel()
      for (var i=0; i<nesting; i++) {
        prefix += "    ";
      }
      var gt = listItem.getGlyphType();
      // Bullet list (<ul>):
      if (gt === DocumentApp.GlyphType.BULLET
          || gt === DocumentApp.GlyphType.HOLLOW_BULLET
          || gt === DocumentApp.GlyphType.SQUARE_BULLET) {
        prefix += "* ";
      } else {
        // Ordered list (<ol>):
        var key = listItem.getListId() + '.' + listItem.getNestingLevel();
        var counter = listCounters[key] || 0;
        counter++;
        listCounters[key] = counter;
        prefix += counter+". ";
      }
    }
  }
  return prefix;
}

//Transfer any leading spaces from inside to end of pre, and trailing spaces from inside to start of post,
//so that bold/italics symbols are adjacent to the words they apply to, without intervening white space.
function compressInside(sections, blank) {
  while (sections.inside.substring(0, 1) == blank) {
    sections.pre = sections.pre + blank; 
    sections.inside = sections.inside.substring(1);
  }
  while (sections.inside.substring(sections.inside.length - 1) == blank) {
    sections.post = blank + sections.post;
    sections.inside = sections.inside.substring(0, sections.inside.length - 1);
  }
}

//Compress inside using spaces, tabs, carriage returns, newlines and form feeds.
function compressInsideWhitespace(sections) {
  compressInside(sections, " ");
  compressInside(sections, "\t");
  compressInside(sections, "\r");
  compressInside(sections, "\n");
  compressInside(sections, "\f");
}

function processTextElement2(inSrc, txt) {
  if (typeof(txt) === 'string') {
    return txt;
  }
  
  var pOut = txt.getText();
  if (! txt.getTextAttributeIndices) {
    return pOut;
  }
  
  //Get the offsets within the text where text formatting runs start
  var attrs=txt.getTextAttributeIndices();

  var s = "";
    
  //Previous offset processed, starts at end of text
  var lastOff=pOut.length;

  //Process the text string in formatting runs, backwards
  for (var i=attrs.length-1; i>=0; i--) {
    //Start of formatting run
    var off=attrs[i];
    var url=txt.getLinkUrl(off);
    var font=txt.getFontFamily(off);

    var sections = {
      inside: pOut.substring(off, lastOff),
      pre: pOut.substring(0, off),
      post: pOut.substring(lastOff)
    }

    //Process URL
    if (url) {  // start of link
      if (i>=1 && attrs[i-1]==off-1 && txt.getLinkUrl(attrs[i-1])===url) {
        // detect links that are in multiple pieces because of errors on formatting:
        i-=1;
        off=attrs[i];
        url=txt.getLinkUrl(off);
      }
      pOut = sections.pre + '[' + sections.inside + '](' + url + ')' + sections.post;
      
    //Process font
    } else if (font) {
      if (!inSrc && font===font.COURIER_NEW) {
        while (i>=1 && txt.getFontFamily(attrs[i-1]) && txt.getFontFamily(attrs[i-1])===font.COURIER_NEW) {
          // detect fonts that are in multiple pieces because of errors on formatting:
          i-=1;
          off=attrs[i];
        }
        pOut = sections.pre + '`' + sections.inside + '`' + sections.post;
      }
    }
    
    //Process bold and/or italic
    if (txt.isBold(off) || txt.isItalic(off)) {
      
      var d1 = d2 = "*";
      
      if (txt.isBold(off)) {
        var d1 = d2 = "**"  
        if (txt.isItalic(off)) {
          d1 = "**_"; d2 = "_**";
        }
      }
      
      //Shrink bold/italic regions to reduce the whitespace they apply to.
      compressInsideWhitespace(sections);
      
      //If we have shrunk the formatted region to nothing, ignore it
      if (sections.inside.length == 0) {
        pOut = sections.pre + sections.post;
        
      //Apply formatting
      } else {      
        pOut = sections.pre + d1 + sections.inside + d2 + sections.post;      
      }
    }
    
    lastOff=off;
  }
  return pOut;
}

function processTextElement(inSrc, txt) {
  if (typeof(txt) === 'string') {
    return txt;
  }
  
  var pOut = txt.getText();
  if (! txt.getTextAttributeIndices) {
    return pOut;
  }
  
  //Get the offsets within the text where text formatting runs start
  var attrs=txt.getTextAttributeIndices();
  
  //Previous offset processed, starts at end of text
  var lastOff=pOut.length;

  //Process the text string in formatting runs, backwards
  for (var i=attrs.length-1; i>=0; i--) {
    //Start of formatting run
    var off=attrs[i];
    var url=txt.getLinkUrl(off);
    var font=txt.getFontFamily(off);
    
    //Process URL
    if (url) {  // start of link
      if (i>=1 && attrs[i-1]==off-1 && txt.getLinkUrl(attrs[i-1])===url) {
        // detect links that are in multiple pieces because of errors on formatting:
        i-=1;
        off=attrs[i];
        url=txt.getLinkUrl(off);
      }
      pOut=pOut.substring(0, off)+'['+pOut.substring(off, lastOff)+']('+url+')'+pOut.substring(lastOff);
      
    //Process font
    } else if (font) {
      if (!inSrc && font===font.COURIER_NEW) {
        while (i>=1 && txt.getFontFamily(attrs[i-1]) && txt.getFontFamily(attrs[i-1])===font.COURIER_NEW) {
          // detect fonts that are in multiple pieces because of errors on formatting:
          i-=1;
          off=attrs[i];
        }
        pOut=pOut.substring(0, off)+'`'+pOut.substring(off, lastOff)+'`'+pOut.substring(lastOff);
      }
    }
    
    //Process bold and bold italic
    if (txt.isBold(off)) {
      var d1 = d2 = "**";
      if (txt.isItalic(off)) {
        // edbacher: changed this to handle bold italic properly.
        d1 = "**_"; d2 = "_**";
      }
      pOut=pOut.substring(0, off)+d1+pOut.substring(off, lastOff)+d2+pOut.substring(lastOff);
      
    //Process italic
    } else if (txt.isItalic(off)) {
      pOut=pOut.substring(0, off)+'*'+pOut.substring(off, lastOff)+'*'+pOut.substring(lastOff);
    }
    
    lastOff=off;
  }
  return pOut;
}
